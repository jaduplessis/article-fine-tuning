[
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```Pursuant to the requirements set forth by the client, the development team was tasked with constructing a highly scalable chat application within a compressed timeframe of four weeks. The impetus for this accelerated development schedule was a significant increase in demand for the client's video conferencing service, which coincided with the onset of the first Covid-19 lockdown and resulted in a strain on their existing systems.\n\nThe chat application was required to meet several key criteria, including the ability to rapidly deploy to production in order to alleviate the strain on the client's systems caused by the increased traffic levels, the capacity to accommodate up to 250,000 chat participants per video event, and the necessity to equip the client's existing development team with the knowledge and skills necessary to maintain and further iterate upon the chat system.\n\nIn order to facilitate real-time communication between users, the development team opted to utilize websockets rather than long-polling, citing the former's superior cost efficiency and performance at scale. The decision to utilize AWS AppSync, a fully-managed Serverless GraphQL interface to various data sources, was made in light of its ability to meet the requirements of speed of delivery, scalability, and ease of use. The development team also considered the use of API Gateway websockets, but ultimately deemed it an unviable option due to the lack of a mechanism for broadcasting messages to all connected clients with a single API call, which would necessitate an API call per connection. Furthermore, the GraphQL interface of AppSync was deemed advantageous for rapid frontend development.\n```"
      },
      {
        "role": "assistant",
        "content": "# Building a Massively Scalable Serverless Chat Application with AWS AppSync\n## Introduction\nWhen demand strikes, developers are tasked with building features quickly. My team knew this all too well when we were set to build a highly scalable chat app in just 4 weeks, when demand for our client\u2019s video conferencing service went through the roof at the beginning of the first Covid-19 lockdown. Google Trends: Searches for \u2018Video Conferencing\u2019 in the UK. There was a significant increase in demand in March 2020.\n\nWhen building the chat application discussed above we had to take into account the following requirements:\n- Release to production quickly \u2014 their systems were failing to cope with the increased traffic levels\n- Scale to 250,000 chat participants per video event\n- Build the capability in their existing development team to maintain and further iterate the chat system\n\nThe chat application needed to have functionality where users could talk to each other in real-time. We used websockets rather than long-polling due to their cost efficiency and performance at scale (read more about the pros and cons of long-polling vs websockets).\n\nThe answer to all of the above was to use AWS AppSync, a fully-managed Serverless GraphQL interface to a number of different data sources \u2014 it offers speed of delivery, scale and ease of use. API Gateway websockets were also considered, but due to our requirements for mass broadcast of messages, it was not a viable option (there is no way to broadcast messages to all connected clients with one API call \u2014 you need an API call per connection). In addition, the GraphQL interface of AppSync allows for rapid frontend development."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```- Used websockets instead of long-polling because they are more cost-effective and performant at scale\n- There are pros and cons to consider when choosing between long-polling and websockets\n\n- Decided to use AWS AppSync, a fully managed serverless GraphQL interface\n- AppSync connects to various data sources\n- It offers speed, scalability, and ease of use\n- Also considered API Gateway websockets but ruled them out\n- Mass broadcasting messages with API Gateway would require an API call for each connection, which wasn't viable\n- The GraphQL interface of AppSync enables fast frontend development\n\n## Architecture \n- This simple setup allowed for quick delivery of the chat app\n- Also provided a clear tech stack for the existing team to learn\n\n- The architecture centers around AppSync\n- It integrates with Cognito user pools for authentication \n- DynamoDB is used as the data source\n\n- The React frontend uses the Apollo Client to send requests to the GraphQL server\n- The Serverless Framework handled infrastructure as code (IaC)\n- The Amplify SDK was used for frontend interaction with the deployed backend services\n```"
      },
      {
        "role": "assistant",
        "content": "We used websockets rather than long-polling due to their cost efficiency and performance at scale (read more about the pros and cons of long-polling vs websockets).\n\nThe answer to all of the above was to use AWS AppSync, a fully-managed Serverless GraphQL interface to a number of different data sources \u2014 it offers speed of delivery, scale and ease of use. API Gateway websockets were also considered, but due to our requirements for mass broadcast of messages, it was not a viable option (there is no way to broadcast messages to all connected clients with one API call \u2014 you need an API call per connection). In addition, the GraphQL interface of AppSync allows for rapid frontend development.\n## Architecture\nThis simple architecture enabled us to have a high speed of delivery for our chat application while also have a clear set of technologies that would need to be taught to the existing team.\n\nThe architecture is based around AppSync, which integrates with Cognito user pools for our authentication. DynamoDB is also leveraged as our data source (read about DynamoDB in the next section).\n\nAll of this hooks up to our React frontend which uses the Apollo Client to fire our requests to the GraphQL server from the frontend. Note, the Serverless Framework was used to manage the IaC (infrastructure as code), while amplify simply provided the SDK for frontend interaction with backend deployed services."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```## Architecture\nThe architecture for the chat application was designed to enable rapid delivery while utilizing a set of technologies that could be easily taught to the existing development team.\n\nThe core of the architecture revolves around AppSync, which integrates with Cognito user pools for authentication. DynamoDB is used as the primary data source (see the next section for more details on DynamoDB).\n\nThe React frontend connects to this backend infrastructure using the Apollo Client to send requests to the GraphQL server. The Serverless Framework was employed to manage the infrastructure as code (IaC), while the Amplify SDK facilitated frontend interaction with the deployed backend services.\n\n## DynamoDB\nDynamoDB, a NoSQL serverless database, provides a fully scalable solution without the need for server management. Designed for large-scale, high-velocity use cases, DynamoDB is trusted by major companies such as Airbnb and Samsung. DynamoDB streams also prove useful for further analytics integrations.\n\nThe seamless integration between AppSync and DynamoDB is advantageous, as it minimizes setup requirements and accelerates the delivery process.\n\n```\nDynamoDB Schema for basic Serverless chat application\n```\n```"
      },
      {
        "role": "assistant",
        "content": "## Architecture\nThis simple architecture enabled us to have a high speed of delivery for our chat application while also have a clear set of technologies that would need to be taught to the existing team.\n\nThe architecture is based around AppSync, which integrates with Cognito user pools for our authentication. DynamoDB is also leveraged as our data source (read about DynamoDB in the next section).\n\nAll of this hooks up to our React frontend which uses the Apollo Client to fire our requests to the GraphQL server from the frontend. Note, the Serverless Framework was used to manage the IaC (infrastructure as code), while amplify simply provided the SDK for frontend interaction with backend deployed services.\n## DynamoDB\nBeing a NoSQL Serverless Database, DynamoDB provides a fully scalable solution to our needs without the need to manage servers. It was built for enormous, high velocity use cases and big companies such as AirBnb and Samsung use the service, so we\u2019re in good company! In addition DynamoDB streams came in use later on for further analytics integrations.\n\nThe fact that AppSync integrates with DynamoDB is ideal as it means we need to do minimal set-up and therefore increase our speed of delivery. \n\n```\nDynamoDB Schema for basic Serverless chat application\n```"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```Here's the neutral version of the text:\n\n- DynamoDB is a NoSQL serverless database that provides a scalable solution without the need to manage servers\n- It was built for large, high-velocity use cases and is used by big companies like AirBnb and Samsung\n- DynamoDB streams can be used for further analytics integrations\n- AppSync integrates with DynamoDB, which minimizes setup and increases speed of delivery\n\n```\nDynamoDB Schema for basic Serverless chat application\n```\n\n- GraphQL is an alternative way to connect client applications to the backend, developed by Facebook to improve bandwidth efficiency\n- With GraphQL, only a single endpoint is called, unlike REST which requires calling separate endpoints for different information\n- Queries in GraphQL are similar to GET requests in REST and are used to fetch data (in this case, from DynamoDB)\n\n```\nSee how we define a query above to get messages. We pass in a roomId as an argument which we can use in our query to only get messages for that specific chat room. We then specify that the return type is an array of messages, where 'Message' is a type.\n```\n```"
      },
      {
        "role": "assistant",
        "content": "## DynamoDB\nBeing a NoSQL Serverless Database, DynamoDB provides a fully scalable solution to our needs without the need to manage servers. It was built for enormous, high velocity use cases and big companies such as AirBnb and Samsung use the service, so we\u2019re in good company! In addition DynamoDB streams came in use later on for further analytics integrations.\n\nThe fact that AppSync integrates with DynamoDB is ideal as it means we need to do minimal set-up and therefore increase our speed of delivery. \n\n```\nDynamoDB Schema for basic Serverless chat application\n```\n## GraphQL Explained\nWith REST we need to call separate endpoints to get the information you require. With GraphQL we need only call the same GraphQL endpoint.\n\nIn a nutshell, GraphQL is an alternative way to connect your client applications to your backend. It was developed at Facebook, to improve bandwidth efficiency since mobile devices don\u2019t always have a good internet connection. Most of us are more familiar with REST, so let\u2019s compare it to GraphQL to get a better understanding.\n\nWhen using GraphQL we simply call one endpoint rather than having separate defined endpoints as in REST.\n## Queries\nQueries in GraphQL are analogous to GET requests in REST. Queries are a way of fetching data (in our case we are fetching from DynamoDB as our database so we\u2019ll use this as our example going forward).\n\n```\nSee how we define a query above to get messages. We pass in a roomId as an argument which we can use in our query to only get messages for that specific chat room. We then specify that the return type is an array of messages, where \u2018Message\u2019 is a type.\n```"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```Here's the neutral version of your text:\n\n- GraphQL is an alternative to REST for connecting client applications to the backend\n- It was developed by Facebook to improve bandwidth efficiency, especially for mobile devices with poor internet connections\n- With GraphQL, you only need to call a single endpoint, unlike REST which requires separate endpoints for different data\n- Mutations in GraphQL are similar to POST requests in REST and are used to modify data\n- The sendMessage mutation takes roomId and message as arguments to add a new item to a DynamoDB table\n- The mutation returns a Message type\n- AppSync subscriptions enable real-time updates\n- In a chat application, you can subscribe to the sendMessage mutation event to update the frontend when a new message is sent\n- The subscription passes the roomId to ensure only users in that specific chat room receive the new messages\n```"
      },
      {
        "role": "assistant",
        "content": "We then specify that the return type is an array of messages, where \u2018Message\u2019 is a type.\n```\n## GraphQL Explained\nWith REST we need to call separate endpoints to get the information you require. With GraphQL we need only call the same GraphQL endpoint.\n\nIn a nutshell, GraphQL is an alternative way to connect your client applications to your backend. It was developed at Facebook, to improve bandwidth efficiency since mobile devices don\u2019t always have a good internet connection. Most of us are more familiar with REST, so let\u2019s compare it to GraphQL to get a better understanding.\n\nWhen using GraphQL we simply call one endpoint rather than having separate defined endpoints as in REST.\n## Mutations\nMutations in GraphQL are similar to POST requests in REST. Mutations do what they say, they are way of mutating the data. \n\n```\nSee above how we set up a sendMessage mutation \u2014 we pass in the roomId and message as arguments so that we can add it with that information as an item to our DynamoDB table. The return type is a Message.\n```\n## Subscriptions\nAppSync subscriptions, which allow for real-time updates, are where the fun begins. For our chat application, we want to \u2018subscribe\u2019 to the mutation event \u2018sendMessage\u2019 so that the frontend application updates when a message is sent with the new message to all users. \n\n```\nYou can see here that we pass in the roomId which means that only users in that particular chat room will be listening for messages sent.\n```"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```Here is the neutral version of the text:\n\nTo enable real-time updates in a chat application when a new message is sent, it is necessary to subscribe to the 'sendMessage' mutation event. This allows the frontend application to receive the new message and update the display for all users in the specific chat room, which is determined by passing the roomId as a parameter.\n\n```\nYou can see here that we pass in the roomId which means that only users in that particular chat room will be listening for messages sent.\n```\n\nIn GraphQL, mutations are used to modify data, similar to POST requests in REST. \n\n```\nSee above how we set up a sendMessage mutation \u2014 we pass in the roomId and message as arguments so that we can add it with that information as an item to our DynamoDB table. The return type is a Message.\n```\n\nResolvers are used to establish the connection between GraphQL and the data source. They are written in Apache Velocity Template Language (VTL), which takes the request as input and outputs a JSON document.\n\nIn cases where multiple operations are required to resolve a GraphQL field, pipeline resolvers can be used in AppSync. Pipeline resolvers consist of a 'before' mapping template, followed by one or more functions, and conclude with an 'after' mapping template.\n\n```\nAs an example we use a pipeline resolver for starting a thread on a question. To make use of single table design we have 'MESSAGE' rows and 'THREAD' rows. When a person replies in a thread, we need to add a THREAD row and mutate the MESSAGE row to add a 'repliedAt' timestamp. This requires 2 separate requests.\n```\n```"
      },
      {
        "role": "assistant",
        "content": "For our chat application, we want to \u2018subscribe\u2019 to the mutation event \u2018sendMessage\u2019 so that the frontend application updates when a message is sent with the new message to all users. \n\n```\nYou can see here that we pass in the roomId which means that only users in that particular chat room will be listening for messages sent.\n```\n## Mutations\nMutations in GraphQL are similar to POST requests in REST. Mutations do what they say, they are way of mutating the data. \n\n```\nSee above how we set up a sendMessage mutation \u2014 we pass in the roomId and message as arguments so that we can add it with that information as an item to our DynamoDB table. The return type is a Message.\n```\n## Resolvers\nWe use Apache VTL for our business logic. In order to communicate with our data source we need to use resolvers \u2014 this is the connection between GraphQL and our data source. The resolvers are written in Apache Velocity Template Language (VTL) which takes the request as an input and outputs a JSON document.\n## Pipeline Resolvers\nSometimes we may need to perform multiple operations to resolve the GraphQL field \u2014 in this case we use a great feature of AppSync called pipeline resolvers. Pipeline resolvers consist of a \u2018before\u2019 mapping template, followed by a number of functions, finishing with an \u2018after\u2019 mapping template.\n\n```\nAs an example we use a pipeline resolver for starting a thread on a question. To make use of single table design we have \u2018MESSAGE\u2019 rows and \u2018THREAD\u2019 rows. When a person replies in a thread, we need to add a THREAD row and mutate the MESSAGE row to add a \u2018repliedAt\u2019 timestamp. This requires 2 separate requests. \n```"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```Pursuant to the requirement of converting the provided text into a neutral and plain version while preserving the core meaning and factual information, the following represents the neutralized version of the aforementioned text:\n\nPipeline Resolvers\nIn certain instances, it may be necessary to execute multiple operations in order to resolve a GraphQL field. In such cases, a feature of AppSync known as pipeline resolvers is utilized. Pipeline resolvers are comprised of a 'before' mapping template, followed by a series of functions, and conclude with an 'after' mapping template.\n\nBy way of illustration, a pipeline resolver is employed for the purpose of initiating a thread on a question. In order to effectively utilize a single table design, 'MESSAGE' rows and 'THREAD' rows are implemented. When an individual replies within a thread, it is necessary to append a THREAD row and modify the MESSAGE row to include a 'repliedAt' timestamp. This process necessitates the execution of two distinct requests.\n\nFrontend \u2014 Amplify & Apollo Client\nFor the purpose of authenticating users, the AWS Amplify SDK is utilized in conjunction with Cognito. Amplify furnishes pre-built UI components to facilitate sign-in and sign-out functionality. The authentication process is configured through the utilization of 'Auth' from aws-amplify and the user pool information (obtained from the Cognito user pool deployed by the Serverless Framework). In order to execute requests from the frontend, the Apollo Client is employed. It is the preferred tool for interacting with the backend due to its compatibility with TypeScript, which provides an optimal developer experience, and its ability to manage state in the frontend through the utilization of a caching mechanism.\n```"
      },
      {
        "role": "assistant",
        "content": "## Pipeline Resolvers\nSometimes we may need to perform multiple operations to resolve the GraphQL field \u2014 in this case we use a great feature of AppSync called pipeline resolvers. Pipeline resolvers consist of a \u2018before\u2019 mapping template, followed by a number of functions, finishing with an \u2018after\u2019 mapping template.\n\n```\nAs an example we use a pipeline resolver for starting a thread on a question. To make use of single table design we have \u2018MESSAGE\u2019 rows and \u2018THREAD\u2019 rows. When a person replies in a thread, we need to add a THREAD row and mutate the MESSAGE row to add a \u2018repliedAt\u2019 timestamp. This requires 2 separate requests. \n```\n## Frontend \u2014 Amplify & Apollo Client\nTo authenticate our users we use the AWS Amplify SDK with Cognito. Amplify provides pre-built UI components to cater for sign-in and sign-out. We configure the authentication by using \u2018Auth\u2019 from aws-amplify and using our user pool information (from the Cognito user pool deployed by the Serverless Framework). To make the requests from the frontend we use the Apollo Client- it is our favourite tool for interacting with our backend as it is compatible with TypeScript, providing a great developer experience, and it manages state in the frontend using a caching mechanism."
      }
    ]
  }
]