[
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```# Development of a Highly Scalable Serverless Chat Application Using AWS AppSync\n## Overview\nDevelopers are often faced with the necessity to create features rapidly as per demand. An illustration of this scenario became apparent when our team was given the responsibility of developing a scalable chat application within a duration of 4 weeks. This happened at the onset of the initial Covid-19 lockdown, which sparked an enormous surge in user demand for our client's video conferencing service. Google Trends registered substantial rises in search trends for 'Video Conferencing' in the UK; particularly in March 2020.\n\nFor the outlined chat application's construction, our task was influenced by the following requirements:\n- Swift release to the production \u2014 the current structure was struggling to handle the abrupt increase in traffic \n- Accommodating up to 250,000 chat members for each video session \n- Enhancing the skills of their existing development force for the future maintenance and continued development of the chat system\n\nThe designed chat application was required to support a function, allowing the enrolled users to interact in real-time. Therefore, we implemented websockets instead of long-polling, owing to their cost-effectiveness and performance on a large scale. \n\nThe key to satisfying the requirements was leveraging AWS AppSync, a fully-automated Serverless GraphQL interface that connects to diverse data sources. It offers expedited delivery, scalability, and user simplicity. We also contemplated API Gateway websockets, but these were ruled out due to our large-scale broadcast needs. Furthermore, the GraphQL interface by AppSync substantially enhances frontend development speed.\n```"
      },
      {
        "role": "assistant",
        "content": "# Building a Massively Scalable Serverless Chat Application with AWS AppSync\n## Introduction\nWhen demand strikes, developers are tasked with building features quickly. My team knew this all too well when we were set to build a highly scalable chat app in just 4 weeks, when demand for our client\u2019s video conferencing service went through the roof at the beginning of the first Covid-19 lockdown. Google Trends: Searches for \u2018Video Conferencing\u2019 in the UK. There was a significant increase in demand in March 2020.\n\nWhen building the chat application discussed above we had to take into account the following requirements:\n- Release to production quickly \u2014 their systems were failing to cope with the increased traffic levels\n- Scale to 250,000 chat participants per video event\n- Build the capability in their existing development team to maintain and further iterate the chat system\n\nThe chat application needed to have functionality where users could talk to each other in real-time. We used websockets rather than long-polling due to their cost efficiency and performance at scale (read more about the pros and cons of long-polling vs websockets).\n\nThe answer to all of the above was to use AWS AppSync, a fully-managed Serverless GraphQL interface to a number of different data sources \u2014 it offers speed of delivery, scale and ease of use. API Gateway websockets were also considered, but due to our requirements for mass broadcast of messages, it was not a viable option (there is no way to broadcast messages to all connected clients with one API call \u2014 you need an API call per connection). In addition, the GraphQL interface of AppSync allows for rapid frontend development."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```We decided to utilize websockets instead of long-polling considering its cost-efficiency and ability to perform at bigger scales (for more understanding about their advantages and disadvantages of long-polling compared with websockets, you can read more).\n\nWe found our solution in AWS AppSync, a completely managed Serverless GraphQL platform to an array of diverse data sources; it provides the speed of delivery, scalability and simplicity in usage. We also contemplated using API Gateway websockets. However, it wasn't fitting for our needs due to our prerequisite for large-scale broadcast of messages, (a significant drawback as there is no way to distribute messages to all the associated clients with a single API call - multiple API calls for each connection is necessary). Furthermore, the GraphQL platform of AppSync enables speedy frontend development.\n\n## Layout of Architecture\nThis sleek layout allows the speedy delivery for our chat app and also introduces an understandable tech stack for the standing team.\n\nOur system architecture is mainly structured around AppSync, which innovatively works with Cognito user pools for user verification. We also make use of DynamoDB as our selected data source (further details of DynamoDB will be mentioned in the proceeding section).\n\nOur architectural setup latches onto our React frontend, which employs the Apollo Client to instigate our requests to the GraphQL server from the frontend. We utilized the Serverless Framework for supervising the IaC (infrastructure as code), whereas Amplify was mainly used for provisioning the SDK for the frontend dealing with backend deployed services.\n```"
      },
      {
        "role": "assistant",
        "content": "We used websockets rather than long-polling due to their cost efficiency and performance at scale (read more about the pros and cons of long-polling vs websockets).\n\nThe answer to all of the above was to use AWS AppSync, a fully-managed Serverless GraphQL interface to a number of different data sources \u2014 it offers speed of delivery, scale and ease of use. API Gateway websockets were also considered, but due to our requirements for mass broadcast of messages, it was not a viable option (there is no way to broadcast messages to all connected clients with one API call \u2014 you need an API call per connection). In addition, the GraphQL interface of AppSync allows for rapid frontend development.\n## Architecture\nThis simple architecture enabled us to have a high speed of delivery for our chat application while also have a clear set of technologies that would need to be taught to the existing team.\n\nThe architecture is based around AppSync, which integrates with Cognito user pools for our authentication. DynamoDB is also leveraged as our data source (read about DynamoDB in the next section).\n\nAll of this hooks up to our React frontend which uses the Apollo Client to fire our requests to the GraphQL server from the frontend. Note, the Serverless Framework was used to manage the IaC (infrastructure as code), while amplify simply provided the SDK for frontend interaction with backend deployed services."
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```## System Design\nOur straightforward layout enabled the increased pace of output for our chat software and additionally provided a distinct batch of tech that required instructing to our existing crew.\n\nThe design relies on AppSync, fused with Cognito user pools for authentication duty. Furthermore, we employed DynamoDB as our storage component (the next section provides more about DynamoDB).\n\nThere's connectivity with our React interface that employs Apollo Client in sending requests to the GraphQL server originating from the interface. Bear in mind, we utilized Serverless Framework to control the IaC (infrastructure as code). Amplify just supplied the SDK for the interface to communicate with backend implemented services.\n## DynamoDB\nDynamoDB, being a NoSQL Serverless Database, affords a completely scalable answer to our requirements, with no server management required. Having been built for towering, swift use cases, renowned firms such as AirBnb and Samsung patronize this facility, hence we can say we share remarkable company! Besides, we gained more benefits from DynamoDB streams later on for additional analytics integration.\n\nThe integration of AppSync with DynamoDB is splendid as it minimizes set-up time significantly enhancing our delivery pace. \n\n```\nDynamoDB Schema for basic Serverless chat application\n```\n```"
      },
      {
        "role": "assistant",
        "content": "## Architecture\nThis simple architecture enabled us to have a high speed of delivery for our chat application while also have a clear set of technologies that would need to be taught to the existing team.\n\nThe architecture is based around AppSync, which integrates with Cognito user pools for our authentication. DynamoDB is also leveraged as our data source (read about DynamoDB in the next section).\n\nAll of this hooks up to our React frontend which uses the Apollo Client to fire our requests to the GraphQL server from the frontend. Note, the Serverless Framework was used to manage the IaC (infrastructure as code), while amplify simply provided the SDK for frontend interaction with backend deployed services.\n## DynamoDB\nBeing a NoSQL Serverless Database, DynamoDB provides a fully scalable solution to our needs without the need to manage servers. It was built for enormous, high velocity use cases and big companies such as AirBnb and Samsung use the service, so we\u2019re in good company! In addition DynamoDB streams came in use later on for further analytics integrations.\n\nThe fact that AppSync integrates with DynamoDB is ideal as it means we need to do minimal set-up and therefore increase our speed of delivery. \n\n```\nDynamoDB Schema for basic Serverless chat application\n```"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```## DynamoDB\nDynamoDB, a NoSQL Serverless Database, offers a scalable solution that meets our needs without the hassle of supervising servers. Big-name businesses such as AirBnb and Samsung are known to avail of this service. Plus, we also found the DynamoDB streams useful for further analytics integrations. \n\nThe compatibility between AppSync and DynamoDB works great for us because it simplifies set-up, making the implementation process quicker. \n\n```\nDynamoDB Schema for basic Serverless chat application\n```\n## Explaining GraphQL\nContrary to REST which requires separate calls to different endpoints to get required information, GraphQL only necessitates a call to the same GraphQL endpoint.\n\nIn simple terms, GraphQL is a different means of linking client applications to your backend. This technology was produced by Facebook primarily for advantageous bandwidth efficiency as mobile devices often struggle with stable internet connection. As most are more acquainted with REST, comparing it to GraphQL might give a clearer perspective.\n\nUnlike REST which has separate defined endpoints, with GraphQL only one endpoint is called.\n## Queries\nThe function of queries in GraphQL can be compared to that of GET requests in REST.  Queries are mainly for data fetching \u2013 in our point of discussion, fetching is from DynamoDB which we use as our database.\n\n```\nObserve the defined query above meant to obtain messages. We provide a roomId as an argument which is then used in our query to acquire messages for that specific chat room only. The return type is defined to be an array of messages, with 'Message' referring to a type.\n```\n```"
      },
      {
        "role": "assistant",
        "content": "## DynamoDB\nBeing a NoSQL Serverless Database, DynamoDB provides a fully scalable solution to our needs without the need to manage servers. It was built for enormous, high velocity use cases and big companies such as AirBnb and Samsung use the service, so we\u2019re in good company! In addition DynamoDB streams came in use later on for further analytics integrations.\n\nThe fact that AppSync integrates with DynamoDB is ideal as it means we need to do minimal set-up and therefore increase our speed of delivery. \n\n```\nDynamoDB Schema for basic Serverless chat application\n```\n## GraphQL Explained\nWith REST we need to call separate endpoints to get the information you require. With GraphQL we need only call the same GraphQL endpoint.\n\nIn a nutshell, GraphQL is an alternative way to connect your client applications to your backend. It was developed at Facebook, to improve bandwidth efficiency since mobile devices don\u2019t always have a good internet connection. Most of us are more familiar with REST, so let\u2019s compare it to GraphQL to get a better understanding.\n\nWhen using GraphQL we simply call one endpoint rather than having separate defined endpoints as in REST.\n## Queries\nQueries in GraphQL are analogous to GET requests in REST. Queries are a way of fetching data (in our case we are fetching from DynamoDB as our database so we\u2019ll use this as our example going forward).\n\n```\nSee how we define a query above to get messages. We pass in a roomId as an argument which we can use in our query to only get messages for that specific chat room. We then specify that the return type is an array of messages, where \u2018Message\u2019 is a type.\n```"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```The return type is defined as an array of 'Message' types. \n\nIn the succeeding section, GraphQL and REST communication methods are examined closely. Instead of accessing different endpoints in order to garner necessary information, the same GraphQL endpoint is called on. GraphQL presents an alternative methodology to link client applications and a backend, designed at Facebook to influence bandwidth efficiency more effectively due to frequent internet connection issues of mobile devices.\n\nGraphQL condenses interactions towards a singular endpoint as opposite to REST's multiple dedicated endpoints. Inside the corresponding section on mutations, it is asserted that they bear resemblance to REST's POST requests, functioning by altering the presented data.\n\nThe creation of a 'sendMessage' mutation is showcased: arguments of the roomId and message are input for it to be appended as a piece of data on the DynamoDB table. Background information indicates that the return type of this operation is a 'Message'. \n\nThe focus then shift to 'subscriptions' in AppSync which are responsible for real-time updates. For a chat function, 'sendMessage' as a mutation event is subscribed to in order to prompt front-end updation each time a new message is disseminated to users. \n\nThe final extract explicates how theroomId is used as a parameter which permits only specified users in a chat room to receive the relayed messages.\n```"
      },
      {
        "role": "assistant",
        "content": "We then specify that the return type is an array of messages, where \u2018Message\u2019 is a type.\n```\n## GraphQL Explained\nWith REST we need to call separate endpoints to get the information you require. With GraphQL we need only call the same GraphQL endpoint.\n\nIn a nutshell, GraphQL is an alternative way to connect your client applications to your backend. It was developed at Facebook, to improve bandwidth efficiency since mobile devices don\u2019t always have a good internet connection. Most of us are more familiar with REST, so let\u2019s compare it to GraphQL to get a better understanding.\n\nWhen using GraphQL we simply call one endpoint rather than having separate defined endpoints as in REST.\n## Mutations\nMutations in GraphQL are similar to POST requests in REST. Mutations do what they say, they are way of mutating the data. \n\n```\nSee above how we set up a sendMessage mutation \u2014 we pass in the roomId and message as arguments so that we can add it with that information as an item to our DynamoDB table. The return type is a Message.\n```\n## Subscriptions\nAppSync subscriptions, which allow for real-time updates, are where the fun begins. For our chat application, we want to \u2018subscribe\u2019 to the mutation event \u2018sendMessage\u2019 so that the frontend application updates when a message is sent with the new message to all users. \n\n```\nYou can see here that we pass in the roomId which means that only users in that particular chat room will be listening for messages sent.\n```"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```The presented chat application entails the feature of 'subscribing' to the mutation event termed 'sendMessage'. This will instigate updates in the frontend application, effectively transmitting the novel dispatched messages to all users. \n\n```\nIndicated here is the fact that the roomId we pass in ensures that only those users occupying a specific chat room will be privy to the circulation of dispatch messages.\n```\n\n## Mutations\nThe concept of mutations underlying GraphQL are akin to POST requests found in REST. The primordial function of mutations remains adherent in the principle of manipulating and modifying data. \n\n```\nOutlined above, we draft a sendMessage mutation \u2014 inclusive of introducing the roomId as well as the message as specific counterarguments, thus enabling the capacity to include it as an individual item in our DynamoDB table. The corroboration for this input process is in the form of delivering a Message type.\n```\n## Resolvers\nIn respect to our business logic operations, we rely on Apache VTL. Explicating the necessity of communicating with our data source warrants the use of resolvers \u2014 this materializes the connection between GraphQL and our data source. The resolvers operate utilizing Apache Velocity Template Language (VTL), which proceeds by acknowledging the request as input, finally translating it into an outputted JSON document.\n## Pipeline Resolvers\nWhere the circumstance necessitates the implantation of multiple operations to transpire the GraphQL field \u2014 the inclusion of pipeline resolvers, an appreciable feature of AppSync becomes convenient. Comprising of a 'before' mapping template, intercepting a progression of functions, culminating into an 'after' mapping template. \n\n```\nTo elaborate, we typically incorporate a pipeline resolver to initiate a new thread on a question. Building on the foundations of single table design, we have 'MESSAGE' rows coupled with 'THREAD' rows. In the course of replaying in a thread, it becomes requisite to implicate a THREAD row and to modify the MESSAGE row for the inclusion of a 'repliedAt' timestamp. As the process requires 2 distinctly separate requests.\n```\n```"
      },
      {
        "role": "assistant",
        "content": "For our chat application, we want to \u2018subscribe\u2019 to the mutation event \u2018sendMessage\u2019 so that the frontend application updates when a message is sent with the new message to all users. \n\n```\nYou can see here that we pass in the roomId which means that only users in that particular chat room will be listening for messages sent.\n```\n## Mutations\nMutations in GraphQL are similar to POST requests in REST. Mutations do what they say, they are way of mutating the data. \n\n```\nSee above how we set up a sendMessage mutation \u2014 we pass in the roomId and message as arguments so that we can add it with that information as an item to our DynamoDB table. The return type is a Message.\n```\n## Resolvers\nWe use Apache VTL for our business logic. In order to communicate with our data source we need to use resolvers \u2014 this is the connection between GraphQL and our data source. The resolvers are written in Apache Velocity Template Language (VTL) which takes the request as an input and outputs a JSON document.\n## Pipeline Resolvers\nSometimes we may need to perform multiple operations to resolve the GraphQL field \u2014 in this case we use a great feature of AppSync called pipeline resolvers. Pipeline resolvers consist of a \u2018before\u2019 mapping template, followed by a number of functions, finishing with an \u2018after\u2019 mapping template.\n\n```\nAs an example we use a pipeline resolver for starting a thread on a question. To make use of single table design we have \u2018MESSAGE\u2019 rows and \u2018THREAD\u2019 rows. When a person replies in a thread, we need to add a THREAD row and mutate the MESSAGE row to add a \u2018repliedAt\u2019 timestamp. This requires 2 separate requests. \n```"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "system",
        "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."
      },
      {
        "role": "user",
        "content": "Can you format this text for the ALEIOS style and tone?\n\n```- We sometimes need to use multiple operations to sort out a GraphQL field. We use a feature from AppSync named pipeline resolvers for this. Pipeline resolvers start with a 'before' mapping template, go through a series of functions and then end with an 'after' mapping template.\n- Here is some example code illustrating how a pipeline resolver is used when starting a conversation thread on a question. Due to the single table design, there are 'MESSAGE' rows and 'THREAD' rows. When someone responds to a thread, we have to both add a THREAD row and change the MESSAGE row to include a 'repliedAt' timestamp. These call for two distinct requests.\n\n```\nExample code content.\n```\n\n- For user authentication, we use the AWS Amplify SDK, which connects with Cognito. Amplify comes with ready-to-use UI elements for actions like signing in or out. We set up the authentications by utilizing 'Auth' from aws-amplify, together with the details of our user pool (derived from the user pool built by the Serverless Framework).\n- When making requests from the front end, our go-to tool is the Apollo Client as it works well with TypeScript, making the developer's experience pleasant. Other than that, it efficiently handles state in the front end through a caching procedure.\n```"
      },
      {
        "role": "assistant",
        "content": "## Pipeline Resolvers\nSometimes we may need to perform multiple operations to resolve the GraphQL field \u2014 in this case we use a great feature of AppSync called pipeline resolvers. Pipeline resolvers consist of a \u2018before\u2019 mapping template, followed by a number of functions, finishing with an \u2018after\u2019 mapping template.\n\n```\nAs an example we use a pipeline resolver for starting a thread on a question. To make use of single table design we have \u2018MESSAGE\u2019 rows and \u2018THREAD\u2019 rows. When a person replies in a thread, we need to add a THREAD row and mutate the MESSAGE row to add a \u2018repliedAt\u2019 timestamp. This requires 2 separate requests. \n```\n## Frontend \u2014 Amplify & Apollo Client\nTo authenticate our users we use the AWS Amplify SDK with Cognito. Amplify provides pre-built UI components to cater for sign-in and sign-out. We configure the authentication by using \u2018Auth\u2019 from aws-amplify and using our user pool information (from the Cognito user pool deployed by the Serverless Framework). To make the requests from the frontend we use the Apollo Client- it is our favourite tool for interacting with our backend as it is compatible with TypeScript, providing a great developer experience, and it manages state in the frontend using a caching mechanism."
      }
    ]
  }
]