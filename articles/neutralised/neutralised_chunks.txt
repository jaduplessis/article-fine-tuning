Building a Chat App using AWS AppSync for Massive Scalability
## Basic Info
Let's make our lives easier - we needed to build a mega-scalable chat app in just 4 weeks as our client's video conferencing service went nuts due to the first Covid-19 lockdown. Searches for 'Video Conferencing' skyrocketed in the UK in March 2020, and our team got the job of responding to that spike.

For this gleaming new chat application, here's our checklist:
- Swift deployment. The client's servers were crumbling under the traffic surge. 
- Disaster-proof scaling. We're prepping for up to 250,000 bodies chatting per video event.
- Internal maintenance. We want our devs to be able to add to this. No silent handovers.

Obviously, the chat app needed real-time chatting capabilities. Think websockets, not long-polling. The why is pretty simple – cost and performance at large scales. 

Want to solve all these problems with one neat little solution? Enter AWS AppSync. This beauty comes with a fully-managed Serverless GraphQL interface that juggles different data sources. It dispatches the delivery speed, scales smoothly, and is super user-friendly. We thought about API Gateway websockets, but we needed to message-blast, and an API per connection isn't gonna cut it. Plus, the GraphQL interface on AppSync lets you fast-track frontend development.

We chose websockets over long-polling due to its fiscal value and performance benefits when operating on a large-scale (examine more about the advantages and disadvantages of long-polling vs websockets).

A solution was found in AWS AppSync, a fully-regulated Serverless GraphQL tool with multiple data sources - It provides fast delivery, wide reach, and user convenience. We also looked into API Gateway websockets however, for large-scale communication of messages, it was dismissed as an insufficient choice (it isn't possible to send the same message to all connected users with a single API call – instead, each connection needs a separate API call). Also, the GraphQL setup of AppSync accelerates the speed of frontend evolution.
## Design
This clean-cut setup was key in providing our chat app with fast delivery while also stating clearer technologies for staff to learn.

The design is built around AppSync, which works in harmony with Cognito user pool for our authentication process. We also used DynamoDB as our data source (read further into DynamoDB in the following portion).

All of these connect to our React Frontend that uses the Apollo Client to dispatch our queries to the GraphQL server from the frontend. Take into account, the Serverless Framework was the choice for managing the IaC (infrastructure as code), while amplify essentially gave the SDK for frontend dialogue with the already deployed backend servers.
## Structure
The integral system design facilitated rapid delivery for our chat software. It also identified a clear array of technologies required for knowledge dissemination amongst the current team.

Foundational to the design is AppSync which has integration capabilities with Cognito user pools assigned for the function of authentication. Additionally, we have taken advantage of DynamoDB to act as our data source (details pertaining to DynamoDB usage are discussed in the subsequent section).

The entire system links with our React frontend that employs Apollo Client. Apollo Client initiates our requests to the GraphQL server from the frontend. Clarification should be given that the Serverless Framework was employed for steering the IaC (Infrastructure as Code), while Amplify provided only the Software Development Toolkit for frontend interaction with backend operational services.
## DynamoDB
As a NoSQL Serverless Database, DynamoDB provides a highly scalable solution capable of addressing our needs without necessitating server management. It was developed to handle massive, high-frequency user scenarios. Large corporations such as AirBnb and Samsung avail this service, aligning us alongside these prominent users. Supplementary to this, DynamoDB streams were leveraged later for wider integration of analytics.

The ability of AppSync to readily amalgamate with DynamoDB is advantageous. This leads to the reduction of set-up necessitated, thereby enhancing our speed of implementation.

```
DynamoDB Schematic for azure Serverless chat platform
```
## DynamoDB
DynamoDB, a NoSQL Serverless Database, offers a scalable solution that doesn’t require server management. Designed for big-scaling and high-speed requirements, it's used by notable corporations like Airbnb and Samsung. DynamoDB streams have additional utility as they are employed for enhanced analytical integrations.

DynamoDB integrates with AppSync which simplifies the setup process and expedites delivery.

```
DynamoDB Schema for basic Serverless chat application
```
## Explanation of GraphQL
Unlike REST, which requires calling different endpoints to procure needed data, GraphQL only needs a single call to the same endpoint.

Essentially, GraphQL serves as an alternate way to link client applications to the backend. It was designed at Facebook to enhance bandwidth efficiency, especially for mobile devices with unstable internet connections. To better understand GraphQL, it could be compared to REST, a system most people are more familiar with.

In executing GraphQL, it is typical to call only one endpoint, diverging from REST's need for separately defined endpoints.
## Queries
In GraphQL, Queries are similar to REST's GET requests. They enable a way to retrieve data. In this particular case, the data will be retrieved from DynamoDB, settling it as the future example database.

```
In the provided example above, a query is defined to obtain messages, passing roomId as an argument to assist in curating messages specifically for the designated chat room. The returned result is specified as a message array, where 'Message' is a type.
```
The output is defined as an array of 'Message' type. 
```
## Understanding GraphQL
In REST, different endpoints need to be called to fetch different information while in GraphQL, the same endpoint needs to be called.

Simply put, GraphQL is a different way to connect your client-side applications with your server. It was launched by Facebook to improve the functioning of mobile applications on weak internet connections. Compared to REST, which we're quite familiar with, we can obtain a better understanding of it.

In GraphQL, we generally call a single endpoint, which is different from REST, where multiple, defined endpoints are used.
## Regarding Mutations
Mutations in GraphQL can be equated to POST requests in REST. As the name suggests, mutations are used to modify data. 

```
This is an example of a sendMessage mutation, where roomId and message are passed as arguments to add an item into our DynamoDB table. The result of this operation is termed a Message.
```
## About Subscriptions
AppSync subscriptions allow for real-time updates, adding an interactive element to applications. For instance, in a chat application, we would want to be notified of the 'sendMessage' mutation event so that the interface gets refreshed when a new message is dispatched to all users.

```
Above, roomId is passed so only individuals present in the specified chatroom will be able to hear the messages being broadcast.
```
We want our chat application to subscribe to the 'sendMessage' mutation event so that it updates once a message is sent, displaying the new message to all users. 

```
Here we can see we provide the roomId, meaning, only users in that particular chat room will receive the sent messages.
```
## Mutations
Mutations in GraphQL are akin to POST requests in REST. As implied by the term, mutations are used for modifying data. 

```
Above illustrates the setup of a sendMessage mutation. We give the roomId and message as arguments to append it as an item to our DynamoDB table along with this information. The return type here is a Message.
```
## Resolvers
Our business logic employs Apache VTL. To link with our data source, we use resolvers, which serve as the bridge between GraphQL and our data. The resolvers are penned in Apache Velocity Template Language (VTL) that accepts the request as an input and dispenses a JSON document as output.
## Pipeline Resolvers
At times, we might have to carry out different operations to resolve the GraphQL field. In such instances, we use one of AppSync's key features named as pipeline resolvers. These go through stages including a 'before' mapping template, various functions, and conclude with an 'after' mapping template.

```
To give promotion to such instances, we utilize a pipeline resolver for initiating a thread on a question in our design which features 'MESSAGE' rows and 'THREAD' rows as single table layout. Whenever a response is posted in a thread, it's necessary to append a THREAD row and modulate the MESSAGE row causing the addition of a 'repliedAt' timestamp. That makes it mandatory to have two separate requests. 
```
## Pipeline Resolvers
Under certain circumstances, it might become necessary to undertake multiple activities to accurately determine the GraphQL field. This necessitates the usage of an essential feature known as pipeline resolvers provided by AWS AppSync. The pipeline resolvers are organized into the initial 'before' mapping template, certain appointed functions follow, and finally, the 'after' mapping template make its due appearance.

```
This hypothetical instance indicates the use of a pipeline resolver while initiating a thread related to a query. Utilization of a singular table design incorporates the induction of 'MESSAGE' rows and 'THREAD' rows. As a thread garners a response from an individual, it leads to the inclusion of a THREAD row and the mutation of a MESSAGE row to append a reliable 'repliedAt' timestamp. This process calls for individual requests, accounted to be numbering at two.
```
## Frontend — Amplify & Apollo Client
The frontend interface relies heavily on the integration of AWS Amplify SDK with Cognito to facilitate the authentication process for each user. Practically, Amplify facilitates pre-configured UI components that manage user sign-in and sign-out. The authentication protocol is regulated by tapping into 'Auth' branching out from aws-amplify and employing the data related to the user pool curated through the Cognito user pool structured by the Serverless Framework. Handling requests extended from the frontend becomes feasible with the help of Apollo Client - this is the preferred instrument for seamless interaction with the backend being majorly compatible with TypeScript. Furthermore, it efficiently manages the state in the frontend through a dedicated caching mechanism.
