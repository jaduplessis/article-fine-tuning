{"messages": [{"role": "system", "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."}, {"role": "user", "content": "Can you format this text for the ALEIOS style and tone?\n\n```Securing CI/CD roles is a crucial aspect of maintaining a secure and reliable deployment process. While using dedicated CI/CD roles and identity federation mitigates the risk of compromised credentials, supply chain attacks remain a concern. Attackers can potentially compromise dependencies such as Docker images or static analysis tools used in the CI/CD pipeline.\n\nThe question of how to properly limit the permissions of CI/CD roles is a common one. The principle of least privilege suggests restricting the role's permissions to only what is necessary. Two common approaches are:\n\n1. Starting with a blank slate and incrementally adding permissions until the application can be deployed successfully. This approach is time-consuming and laborious.\n\n2. Starting with the AdministratorAccess policy, allowing the role broad permissions. Then, using CloudTrail to track the actions performed by the role over time and creating a tailored set of IAM permissions based on the CloudTrail data.\n\nBoth approaches have significant drawbacks in the long run. The first approach is tedious and may lead to incomplete permissions, causing deployment failures. The second approach, while initially convenient, can result in excessive permissions being granted to the CI/CD role, increasing the potential impact of a compromised pipeline.\n```"}, {"role": "assistant", "content": "# How to secure CI/CD roles without burning production to the ground\n\nBy now, most of us have moved away from using IAM users for CI/CD pipelines. Instead, we\u2019d use dedicated CI/CD roles, one for each pipeline. This forces us to consider who can assume this role. Identity federation is widely supported by 3rd-party providers such as GitHub Actions [1]. So, no more putting IAM credentials in CI/CD tools and worry that they might be compromised in a security breach [2].\n\nHowever, attackers can still compromise the pipeline through supply chain attacks. For example, by compromising a Docker image we depend on in our CI/CD pipeline. Or by compromising static analysis tools such as eslint [3]. So, the question of \u201c How best to limit CI/CD role\u2019s permissions?\u201d has come up many times during my Production-Ready Serverless [4] workshop. Your instinct might be to lock down the CI/CD role to just what it needs. Because we all want to follow the principle of least privilege. There are different ways to achieve this. Here are two common approaches:\n\n1. Start with a blank slate and add permissions to the role until it\u2019s able to deploy your application.\n2. Start with the AdministratorAccess policy and allow the role to do everything. Use CloudTrail to track the actions performed by the role over some time. Then use the CloudTrail data to create a tailored set of IAM permissions.\n\nThe first approach is very time-consuming and laborious and is best avoided. But in truth, both approaches have significant drawbacks in the long run."}]}
{"messages": [{"role": "system", "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."}, {"role": "user", "content": "Can you format this text for the ALEIOS style and tone?\n\n```Your text raises valid concerns regarding the challenges of implementing the principle of least privilege for CI/CD roles in AWS. Here is a neutral summary:\n\nGranting appropriate permissions to a CI/CD role is a delicate balance between security and functionality. The principle of least privilege recommends starting with minimal permissions and adding only necessary ones. However, this approach can be time-consuming and prone to overlooking required permissions, leading to deployment failures and rollback issues.\n\nAn alternative is to start with broad administrative access, monitor the role's actions via CloudTrail, and then create a tailored permission set. While more permissive initially, this method aims to capture all required permissions upfront.\n\nBoth approaches have drawbacks. The least privilege method requires meticulous analysis and may still miss permissions needed for rollbacks. The broad access method introduces potential security risks during the monitoring period.\n\nUltimately, granting CI/CD role permissions requires careful consideration of security best practices, deployment requirements, and the trade-offs between the two approaches. Thorough testing and monitoring are crucial to ensure the role has the necessary permissions while minimizing excessive privileges.\n```"}, {"role": "assistant", "content": "Your instinct might be to lock down the CI/CD role to just what it needs. Because we all want to follow the principle of least privilege. There are different ways to achieve this. Here are two common approaches:\n\n1. Start with a blank slate and add permissions to the role until it\u2019s able to deploy your application.\n2. Start with the AdministratorAccess policy and allow the role to do everything. Use CloudTrail to track the actions performed by the role over some time. Then use the CloudTrail data to create a tailored set of IAM permissions.\n\nThe first approach is very time-consuming and laborious and is best avoided. But in truth, both approaches have significant drawbacks in the long run.\n## Rollback surprises\n\nFor most people, CloudFormation rollbacks don\u2019t happen often. Especially for those of us who don\u2019t write CloudFormation templates by hand. So when a deployment fails for the first time, you find out that the CI/CD role is missing a whole bunch of permissions! This can leave you in an awkward position where your stack is stuck in the ROLLBACK_FAILED state. And you are stuck until you resolve the missing permissions. In essence, crafting a least privileged CI/CD role takes twice as much work as you think. Because you also need to factor in all the permissions for rollbacks."}]}
{"messages": [{"role": "system", "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."}, {"role": "user", "content": "Can you format this text for the ALEIOS style and tone?\n\n```Neutral text:\n\n- CloudFormation rollbacks might emerge as a surprise, especially for people who don't write CloudFormation templates. When deployment failure occurs the first time, you might realize many permissions in the CI/CD role are missing. This often leaves your stack in a 'ROLLBACK_FAILED' state and won't resolve until you fix these missing permissions. Therefore, creating a least privileged CI/CD role may need more effort than expected as it also includes permissions for rollbacks.\n\n- Keep in mind that your architecture is never constant. It evolves along with your application and business needs. So, when you include a new service, you'll have to revise the CI/CD role as well. Whether it is starting using OpenSearch or Bedrock, you'll need to update the CI/CD role before anything else. This can be time-consuming, especially in organizations where the application team doesn't manage the CI/CD role. This back-and-forth often results in productivity loss. The process repeats for every new service because each has its separate CI/CD pipeline. It creates ongoing challenges to productivity, stifles innovation, and slows down the inclusion of new services to the tech stack. After all, using a new service implies new CI/CD permissions which may lead to dealing with lots of red tape.\n```"}, {"role": "assistant", "content": "## Rollback surprises\n\nFor most people, CloudFormation rollbacks don\u2019t happen often. Especially for those of us who don\u2019t write CloudFormation templates by hand. So when a deployment fails for the first time, you find out that the CI/CD role is missing a whole bunch of permissions! This can leave you in an awkward position where your stack is stuck in the ROLLBACK_FAILED state. And you are stuck until you resolve the missing permissions. In essence, crafting a least privileged CI/CD role takes twice as much work as you think. Because you also need to factor in all the permissions for rollbacks.\n## A tax on productivity\n\nYour architecture is not static. It needs to evolve with your application and your business needs. Every time you introduce a new service, you also need to revise the CI/CD role. Want to start using OpenSearch? Not before you update the CI/CD role! Want to start using Bedrock? Not before you \u2026 you get the point. In organizations where the application team doesn\u2019t own the CI/CD role, this productivity tax can be steep. It requires many back-and-forth between teams and hits productivity hard. And you likely have to do these for every service because every service has its own CI/CD pipeline. This friction is a constant tax on your productivity. It hampers innovation and delays the adoption of new services into the tech stack. Because introducing a new service means new CI/CD permissions. Who in their right mind wants to deal with all that bureaucracy?"}]}
{"messages": [{"role": "system", "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."}, {"role": "user", "content": "Can you format this text for the ALEIOS style and tone?\n\n```Here are some key points about managing CI/CD roles and permissions:\n\n- In many organizations, application teams don't own the CI/CD role, leading to productivity bottlenecks when adopting new services that require updating permissions.\n- Every service has its own CI/CD pipeline, so this friction is a constant tax on productivity and hampers innovation.\n- While least privileged CI/CD roles aim to reduce security risks, they are not foolproof:\n    - The CI/CD role likely needs permissions to deploy IAM roles and Lambda functions.\n    - In case of a breach, attackers can create confused deputies like rogue IAM roles or malicious Lambdas.\n    - Permission boundaries can mitigate some risks but are complex to implement correctly for each pipeline.\n- The core issue is the bureaucracy and overhead involved in managing CI/CD permissions across multiple pipelines and services.\n- This highlights the need for a more streamlined and secure approach to managing CI/CD access and privileges.\n```"}, {"role": "assistant", "content": "Want to start using OpenSearch? Not before you update the CI/CD role! Want to start using Bedrock? Not before you \u2026 you get the point. In organizations where the application team doesn\u2019t own the CI/CD role, this productivity tax can be steep. It requires many back-and-forth between teams and hits productivity hard. And you likely have to do these for every service because every service has its own CI/CD pipeline. This friction is a constant tax on your productivity. It hampers innovation and delays the adoption of new services into the tech stack. Because introducing a new service means new CI/CD permissions. Who in their right mind wants to deal with all that bureaucracy?\n## They are not as safe as you think\n\nThe reason why we pursue least privileged CI/CD roles is to reduce the blast radius of a security breach. If an attacker compromises our CI/CD pipeline, we want to limit what the attacker can do. However, the CI/CD role likely needs to deploy IAM roles and Lambda functions. In the event of a compromise, a least privileged CI/CD role is not enough to stop the attacker. Because the attackers can use the CI/CD role to create confused deputies to act on their behalf. For example, attackers can use the CI/CD role to create IAM roles for them to assume. And they can also create Lambda functions to carry out malicious activities. We can mitigate these risks to some extent with permission boundaries. But that requires lots more work and it\u2019s hard to get right. And again, you have to do it for every CI/CD role."}]}
{"messages": [{"role": "system", "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."}, {"role": "user", "content": "Can you format this text for the ALEIOS style and tone?\n\n```The passage discusses the risks associated with compromised CI/CD pipelines and the challenges of implementing a least privileged approach. It then proposes an alternative approach to securing CI/CD pipelines by using separate AWS accounts for different environments and teams. The key points are:\n\n1. If an attacker compromises the CI/CD pipeline, they can potentially create IAM roles and Lambda functions to carry out malicious activities, making a least privileged CI/CD role insufficient to mitigate risks.\n\n2. Implementing permission boundaries to limit the CI/CD role's capabilities requires significant effort and can be challenging to implement correctly.\n\n3. Instead of pursuing a least privileged CI/CD role, the author suggests using separate AWS accounts for each environment (e.g., development, production) to isolate potential compromises.\n\n4. For large organizations, it is recommended to have at least one account per team per environment to further insulate teams from each other's mistakes.\n\n5. For business-critical systems, it is advisable to have a dedicated account per service per environment to provide an additional layer of protection.\n\nThe passage argues that separating environments and teams into distinct AWS accounts can effectively contain the impact of a compromised CI/CD pipeline, reducing the need for complex and potentially error-prone permission management within a single account.\n```"}, {"role": "assistant", "content": "If an attacker compromises our CI/CD pipeline, we want to limit what the attacker can do. However, the CI/CD role likely needs to deploy IAM roles and Lambda functions. In the event of a compromise, a least privileged CI/CD role is not enough to stop the attacker. Because the attackers can use the CI/CD role to create confused deputies to act on their behalf. For example, attackers can use the CI/CD role to create IAM roles for them to assume. And they can also create Lambda functions to carry out malicious activities. We can mitigate these risks to some extent with permission boundaries. But that requires lots more work and it\u2019s hard to get right. And again, you have to do it for every CI/CD role.\n## Prefer a permissive role that is hard to abuse\n\nIt\u2019s counterproductive to blindly pursue least privileged CI/CD roles. Beyond a certain point, you get diminished return-on-investments. That is, you have to work much harder to address security risks that are unlikely to happen. With that in mind, here\u2019s my preferred approach to securing a CI/CD pipeline.\n\nUse a separate AWS account for each environment\n\nThis is something everyone should do. It insulates environments from each other. If one environment is compromised, it\u2019s contained by the account boundary. If an attacker compromises your dev environment, they won\u2019t be able to access your production data.\nFor large organizations, you should go a step further. I recommend having at least one account per team per environment. That way, teams are insulated from other teams\u2019 mistakes.\nFor business critical systems, they should have their own set of accounts too. That is one account per service per environment. It\u2019s not always necessary. But it\u2019s a good idea to protect these business critical systems from other systems."}]}
{"messages": [{"role": "system", "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."}, {"role": "user", "content": "Can you format this text for the ALEIOS style and tone?\n\n```Different environments are separated by an isolating barrier. If one part becomes vulnerable, it is restrained to that area by the account barrier. In other words, if a hacker finds a vulnerability in your development environment, they will not be able to penetrate your production data.\nFor larger corporations, it may be beneficial to go even further. It is advisable to have at least one account for each separate team for each environment. In this way, teams would not be affected by the errors of other groups.\nFor systems critical to the running of the business, they should also have standalone accounts. This indicates one account for each service in each environment. While this is not mandatory, it is helpful in safeguarding these critical systems against flaws in other parts of the system.\n## Service Control Policies (SCPs)\n\nMake use of SCPs to restrict access to idle resources. These comprehensive limitations include opportunities to block access to unused Amazon Web Services (AWS) foregrounds and non-working services. This could potentially remove major parts of AWS as possible areas for attack.\nIf you are not currently governing any virtual computing environments, disallow all activities related to this. This would be one less potential spot for crypto-jacking attacks. Nonetheless, EC2 Container Service (ECS) has become the latest area for crypto-jacking. If complete disabling of ECS is not an option, the least action to take would be to restrict entry to regions where there are no containers at hand.\n## Attribute-Based Access Control (ABAC)\n\nThe implementation of ABAC is steadily improving its status, in spite of its present middling standard. Having said that, numerous services do already accept the `aws:ResourceTag/${TagKey}` and `aws:PrincipalTag/${TagKey}` circumstances. Use these conditions to hinder attackers from gaining access to and developing resources. Attach these to the identity access management (IAM) permissions of the CI/CD position. Alternatively, use these as a checkpoint enacted through a scope limitation.\nThe mentioned conditions will function best when the CI/CD role is prohibited from inquiring about itself. Only in this way can hackers not discover which markers the CI/CD role has and which markers they need to produce new resources. This helps prevent an attacker from infiltrating our resources via the CI/CD role. Nevertheless, attackers may turn to the services below to utilise harmful code or assert an elevated level of threats:\n - Lambda\n - EC2\n - ECS\n - IAM\n - CodePipeline\n - CloudFormation\nOn the bright side, all of these services, along with many others, value the `aws:ResourceTag/${TagKey}` condition. We should use this condition as a protective shield, preventing the attacker from producing any new resources.\n```"}, {"role": "assistant", "content": "It insulates environments from each other. If one environment is compromised, it\u2019s contained by the account boundary. If an attacker compromises your dev environment, they won\u2019t be able to access your production data.\nFor large organizations, you should go a step further. I recommend having at least one account per team per environment. That way, teams are insulated from other teams\u2019 mistakes.\nFor business critical systems, they should have their own set of accounts too. That is one account per service per environment. It\u2019s not always necessary. But it\u2019s a good idea to protect these business critical systems from other systems.\n## Service Control Policies (SCPs)\n\nUse SCPs to deny access to unused resources. These broad strokes include access to unused AWS regions and unused services. This way, you can eliminate large parts of AWS as possible attack surfaces.\nFor example, if you\u2019re not running any EC2 instances, then deny all EC2 activities. That\u2019s one less target for crypto-jacking attacks. But hey, ECS is the new EC2 for crypto-jacking. If you can\u2019t disable ECS as a whole, then at least deny access to the regions where you don\u2019t have any containers.\n## Attribute-Based Access Control (ABAC)\n\nSupport for ABAC is improving all the time, although it\u2019s still lacklustre in its current form. But many services already support the `aws:ResourceTag/${TagKey}` and `aws:PrincipalTag/${TagKey}` conditions. These conditions can be used to stop attackers from accessing and creating resources. They can be added to the IAM permissions of the CI/CD role. Or they can be enforced through a permission boundary.\nTo make them more effective, the CI/CD role should be denied the ability to find out about itself. That way, the attacker can\u2019t find out what tags the CI/CD role has and what tags they need to use to create new resources.\nDoing so helps us stop the attacker from accessing our resources through the CI/CD role. But they might target the following services to execute malicious code or escalate their privilege:\n- Lambda\n- EC2\n- ECS\n- IAM\n- CodePipeline\n- CloudFormation\nLuckily, all these services (and many others) support the `aws:ResourceTag/${TagKey}` condition. We can use this condition to stop the attacker from creating new resources."}]}
{"messages": [{"role": "system", "content": "Gob is a stylistic chatbot that is excellent at rephrasing text."}, {"role": "user", "content": "Can you format this text for the ALEIOS style and tone?\n\n```The effectiveness of these rules can be optimised through a permission boundary. The CI/CD role should be restricted from acquiring knowledge about itself for maximising security measures. This preventive measure ensures that an external invader cannot access information regarding the tags attached to the CI/CD role or ascertain the necessary course of action to generate new resources.\n\nBy doing so, blocking user access to bank resources via the CI/CD role becomes less challenging. Potential targets for malicious activity or privileging escalation could include several services, encompassing the likes of Lamba, EC2, ECS, IAM, Code, Pipeline, or CloudFormation. Fortunately, all these services, among others, extend support for the `aws:ResourceTag/${TagKey}` condition, leveraging this condition to prevent the devised course of action by malicious intruders.\n\n## Implementing a Permissive CI/CD Role\n\nUpon executing the aforementioned tips, it is confirmed that\n\n- The vulnerability surface associated with unused services or regions has been eliminated.\n- The compromising 'blast radius' has been minimally confined to individual teams and services.\n- Making the CI/CD role susceptible to misuse by attackers has been made considerably difficult by enforcing the requirement of legitimate tags on resources. The Intruder is hence unable to decipher this easily given the inaccessibility to describe the CI/CD service as a whole.\n  \nWe are hence under the allowance of garnering a more permissive CI/CID role, while negating challenges in creation or maintenance. it's secure and difficult to exploit, and maintains a limit on actual execution power.\n\nWith the term 'permissive', the intent is not definitively 'AdministratorAccess'. However, it does encourage a level of autonomous control. You can extend broad write and read permissions to all the active services, effortlessly, not necessarily having to specifically highlight the actions you merely require!\n```"}, {"role": "assistant", "content": "Or they can be enforced through a permission boundary.\nTo make them more effective, the CI/CD role should be denied the ability to find out about itself. That way, the attacker can\u2019t find out what tags the CI/CD role has and what tags they need to use to create new resources.\nDoing so helps us stop the attacker from accessing our resources through the CI/CD role. But they might target the following services to execute malicious code or escalate their privilege:\n- Lambda\n- EC2\n- ECS\n- IAM\n- CodePipeline\n- CloudFormation\nLuckily, all these services (and many others) support the `aws:ResourceTag/${TagKey}` condition. We can use this condition to stop the attacker from creating new resources.\n## A permissive CI/CD role\n\nAfter doing the above:\n- We have removed the attack surface associated with unused regions and services.\n- We have limited the blast radius of a compromise to individual teams and services.\n- We have made it difficult for attackers to abuse the CI/CD role by requiring correct tags on resources. Which the attacker is not able to figure out easily because the CI/CD role is not allowed to describe itself.\nNow we can allow ourselves to have a permissive CI/CD role that is not a pain in the ass to create and maintain! Because the role will be difficult to abuse, and there is a ceiling to what it can actually do.\nBy \u201cpermissive\u201d, I don\u2019t necessarily mean \u201cAdministratorAccess\u201d. But you can give broad read & write permissions to all the services you use. Instead of picking out just the actions you need with a fine comb!"}]}
