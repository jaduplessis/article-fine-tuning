
# Building a Serverless Anti-Corruption Layer with CDK

When building large distributed systems, interacting successfully with external systems can introduce large amounts of complexity into your system design. Consider a company’s software system that interacts with a third-party provider. A plan is made to move to a new provider which is faster and cheaper. An issue is identified that the protocol to interact with the old third-party provider is not compatible with the new one. The company will need to modify multiple sections of its software to interact with this new provider. They want to implement a design principle to account for this and allow for easier transitions in future.

A common solution is the Anti-Corruption Layer (ACL). An ACL implements the principles of Domain Driven Design (DDD). DDD is a software development approach that focuses on modelling software based on the real-world business domain it aims to serve. It emphasizes collaboration between technical and domain experts to ensure the software accurately reflects and evolves with the domain. DDD advocates for a ubiquitous language for all stakeholders and organizes the system into bounded contexts to manage complexity. These bounded contexts are called domains but are often referred to as separate services in the context of a distributed system.

ACL follows the principles of DDD by providing a separation of these services, allowing you to structure your business domains most effectively and ensuring that the design and language of your system are protected from 3rd party influence. In addition, when executed correctly an ACL can also prevent vendor lock-in, and provide easier visibility on your system’s architecture.

## What is an ACL?

An Anti-Corruption Layer is a design pattern that provides the functionality to transform or translate information passing from one system to another. It is not purely a mechanism for communicating messages between two systems, instead, it provides guardrails to ensure that misinterpreted data cannot enter into and corrupt your primary system. An ACL can be designed as a package to be reused across other services, or as a self-standing service. By acting as the communication layer between services, an ACL separates and increases decoupling allowing for independent scaling and greater portability of each of the services. Due to its low coupling with the rest of the software system, an external system, like a third-party service above, can be torn out when needed without large changes. This brings the added benefit that decoupled services can now be developed independently of each other increasing developer flexibility and build time.

## ACL as a Service:

An ACL can be created as a package or a fully-fledged service, however, having it as a service will yield the following benefits:

- It encourages the abstraction of protocols that are required to communicate with external services. Building a whole new layer to handle the communication between services can become extremely complex. By encapsulating the ACL as a standalone service, an organisation is likely to have a dedicated team of experts building and maintaining this service. This protects developers from other domains needing knowledge of the intricacies of the ACL domain.
- Very often, logic used to communicate with external services can result in a large repository of code. Having this within a package can quickly become difficult to maintain, document and use by consumers. A service simplifies this complexity by allowing the creation of standalone features, such as dedicated infrastructure and organisation of logic, in a way that best fits the ACL rather than its consuming services.
- In addition, the ACL service itself can leverage internal packages to reuse code across the service and the ACL team will have context on these internal development tools. Ideally, having the ACL as a service, not a module or package within a service, will provide easier construction, understanding, and correct visibility of this tool at the levels required from those in and outside the ACL domain.

## Building Blocks of an ACL:

When building an Anti-Corruption Layer, we can break down its core functionality into three mechanisms: Facades, Adapters, and Translators.

- A **Facade** provides a simplified interface on top of a complex set of underlying classes. In terms of the ACL, it simplifies access for the client by making the subsystem easier to use.
- An **Adapter** allows the client to use a different protocol than the one understood by the system they are trying to interact with.
- The final element is the **Translator**. The Translator’s job can be seen as a subset of the Adapter’s. The translator’s job is to translate the actual logic to be recognisable to the client’s system.

## Building an ACL with Serverless:

Serverless boasts numerous advantages, including the ability to scale to zero cost when not in use, on-demand scaling to efficiently handle varying workloads, and the elimination of traditional server maintenance, leading to significant reductions in operational costs and enhanced resource optimization.

This Serverless infrastructure will be configured using the AWS Cloud Development Kit (CDK) and TypeScript for Infrastructure as Code (IaC). AWS CDK offers the flexibility to design cloud applications in an object-oriented manner using familiar programming languages.

AWS CDK streamlines the process of defining cloud resources in code, allowing for a more organized and manageable infrastructure setup. This method ensures a consistent deployment sequence and makes the infrastructure easily reproducible. Additionally, it significantly improves the ability to debug and resolve configuration issues, as the entire cloud environment is defined programmatically.

The example uses an ACL to interact with a third-party API. See the diagram below for an architecture diagram of the AWS resources used:

```typescript
export const main = async (
  event: APIGatewayProxyEvent | Partial<APIGatewayProxyEvent>,
): Promise<APIGatewayProxyResult> => {
  const authorizationToken = event.headers?.authorizationToken;
  if (authorizationToken === undefined) {
    throw new Error('Authorization token is not valid.');
  }
  let code = event.pathParameters?.code;
  if (code === undefined) {
    code = 'default-code';
  }

  const thirdPartyBaseUrl = 'https://third.party.api';
  const url = `${thirdPartyBaseUrl}/list?code=${code}`;
  const response = await fetch(url, {
    method: 'GET',
    headers: {
      ...event.headers,
      Authorization: authorizationToken,
      'Content-Type': 'application/json',
    },
  });
  if (response.status >= 400 || response.status < 200) {
    const err = new FetchError(response.statusText, `${response.status}`);
    err.code = `${response.status}`;
    throw err;
  }

  const listData = (await response.json()) as ListData;
  let totalValues = 0;
  const listLength = listData.items.length;
  for (let i = 0; i < listLength; i++) {
    totalValues += listData.items[i]?.value ?? 0;
  }
  const listResponse = {
    totalValues: totalValues,
    listLength: listLength,
    ...listData.items,
  };
  return {
    statusCode: 200,
    body: JSON.stringify(listResponse),
  };
};
```

Building an Anti-Corruption layer can be a complex and resource-intensive task. It is important to ensure communication boundaries have been addressed between teams that will use this layer and that sufficient resources have been procured to build and maintain it. However, if created correctly, an ACL can provide the best protection for your system acting as a guard to prevent influence and leakage of design patterns from external systems. An ACL allows you to follow the principles of Domain Driven Design in your company’s system no matter the 3rd party systems you interface with. It also allows you to swap and change external systems more easily without large and fundamental code changes, reducing vendor lock-in. The principles of an ACL such as Facades, Adapters and Translators can be applied to the simplest of systems as well as to the most complex of enterprise software.
