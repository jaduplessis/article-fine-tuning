
# Integration Testing Step Functions: Using sls-test-tools

## The states which make up a Step Function
A Step Function is a state machine, where states have types, namely:
- Task state: for performing an operation
- Choice state: for choosing which branch of the state machine to execute next
- Fail/Succeed state: for ending the execution of a state machine
- Pass state: for passing its input to output, or injecting fixed data
- Wait state: for imposing a delay into the execution of the state machine
- Parallel state: for creating parallel branches of execution in the state machine
- Map state: for performing the same state action for each item in a list

## Should we test Step Functions?
As with any AWS infrastructure, we need to be able to test it, so that we know we’ve configured it correctly and so that it can't be broken in the future. It's important to test the logic in the individual states, as well as the overall state machine. Testing on the real infrastructure is recommended to best simulate the real production environment.

## Unit vs Integration Testing
Unit tests focus on testing individual pieces of code, whereas integration tests check that various pieces of our system are interacting correctly with each other. It is important to have both! Testing individual states is relatively simple, while integration tests are slightly more complex but crucial.

## Introducing Step Functions assertions with sls-test-tools
The below code samples will demonstrate how to test a step function called 'TestAddAndDouble' which contains two task states, one which sums two numbers, and another which doubles the number.

### Assert that the state machine has the correct execution status
First let’s test that we get to a Succeeded status when we pass a valid input. To do this we can use the new `toHaveCompletedExecutionWithStatus()` assertion. This allows us to type in the name of the state machine we’ve executed, as well as the expected status for the execution. It then checks that the most recent execution of the state machine has the expected status.

### Now let’s check we get the right output given a valid input
For example, if we enter {3, 6} we expect to get 18 as the output. We can once again use a new assertion, the `toMatchStateMachineOutput` assertion. This allows us to type in the name of the state machine we’ve executed, as well as the expected output for this execution, and checks that the most recent execution of the state machine produced the expected output. Here is an example of the usage of this assertion:

```javascript
// Helper: Execute the Step Function until its completed
```

You’ll have noticed above that we had to rely on the step function having been executed. Rather than require a manual step or complex call to the API we’ve also bundled in a helper function to simplify execution and wait for execution to complete. Here is an example of the call to the helper:

### Putting it all together
Now if we combine the use of this helper, and our two assertions we can see a mature test suite for our TestAddAndDouble Step Function.

## Conclusion
With Serverless, integration testing against the real services is more important than ever, and Step Functions are far too often neglected! sls-test-tools now provides a helper which allows us to execute a Step Function until completion, and two new assertions to check that the Step Function is configured correctly (i.e. it provides the right output for a variety of inputs, and consistently completes with the correct execution status). Check out sls-test-tools here! P.S. sls-test-tools is now typed, so it can be used in your next Typescript project!
